"""SKILL.md generation from Tooli app introspection."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from tooli.app import Tooli


def generate_skill_md(app: Tooli) -> str:
    """Generate SKILL.md content for a Tooli application."""
    lines: list[str] = []
    name = app.info.name or "tooli-app"
    description = app.info.help or "An agent-native CLI application."

    lines.append(f"# {name}")
    lines.append("")
    lines.append(description)
    lines.append("")
    lines.append("## Commands")
    lines.append("")

    tools = app.get_tools()
    
    # Synopses
    for tool_def in tools:
        if tool_def.hidden:
            continue
        short_help = (tool_def.help or tool_def.callback.__doc__ or "").split("\n")[0]
        lines.append(f"* **{tool_def.name}**: {short_help}")

    lines.append("")

    for tool_def in tools:
        if tool_def.hidden:
            continue
            
        lines.append(f"### `{tool_def.name}`")
        lines.append("")
        help_text = tool_def.help or tool_def.callback.__doc__ or ""
        lines.append(help_text)
        lines.append("")

        callback = tool_def.callback
        annotations = getattr(callback, "__tooli_annotations__", None)
        if annotations:
            from tooli.annotations import ToolAnnotation
            hints: list[str] = []
            if isinstance(annotations, ToolAnnotation):
                hints = []
                if annotations.read_only:
                    hints.append("read-only")
                if annotations.idempotent:
                    hints.append("idempotent")
                if annotations.destructive:
                    hints.append("destructive")
                if annotations.open_world:
                    hints.append("open-world")
                if hints:
                    lines.append(f"**Behavior**: `[{', '.join(hints)}]`")

            lines.append("#### Governance")
            lines.append(f"**Annotations**: `{', '.join(hints) if hints else '[]'}`")
            cost_hint = getattr(callback, "__tooli_cost_hint__", None)
            if cost_hint is not None:
                lines.append(f"**Cost Hint**: `{cost_hint}`")
            else:
                lines.append("**Cost Hint**: `unspecified`")

            human_in_the_loop = bool(getattr(callback, "__tooli_human_in_the_loop__", False))
            lines.append(f"**Human In The Loop**: `{'true' if human_in_the_loop else 'false'}`")
            lines.append("")

        required_scopes = getattr(callback, "__tooli_auth__", [])
        if required_scopes:
            lines.append(f"**Required Scopes**: `{', '.join(required_scopes)}`")

        examples = getattr(callback, "__tooli_examples__", [])
        if examples:
            lines.append("")
            lines.append("**Examples**:")
            for ex in examples:
                args = " ".join(ex.get("args", []))
                lines.append(f"```bash\n{name} {tool_def.name} {args}\n```")
                desc = ex.get("description")
                if desc:
                    lines.append(f"> {desc}")
            lines.append("")

    lines.append("## Exit Codes")
    lines.append("")
    lines.append("| Code | Meaning |")
    lines.append("|---|---|")
    lines.append("| 0 | Success |")
    lines.append("| 2 | Invalid usage / validation error |")
    lines.append("| 10 | Not found / state error |")
    lines.append("| 30 | Permission denied |")
    lines.append("| 50 | Timeout / temporary external delay |")
    lines.append("| 70 | Internal or runtime error |")
    lines.append("| 101 | Human handoff required |")
    lines.append("")
    lines.append("Generated by Tooli.")

    return "\n".join(lines)
